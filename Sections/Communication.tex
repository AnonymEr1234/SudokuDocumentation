\subsection{Kommunikation per POST-Anfrage}

Die Kommunikation zwischen Frontend und Backend erfolgt über \texttt{POST}-Anfragen. Das Frontend sendet dabei die benötigten Daten im JSON-Format an einen definierten API-Endpunkt des Backends (Port 8080).  
Es werden zwei Modi unterschieden:
\begin{enumerate}
	\item \textbf{Generieren von Sudokus}
	\item \textbf{Lösen von Sudokus}
\end{enumerate}

Im Generierungsmodus gilt folgende Zahlenrepräsentation:
\begin{itemize}
	\item \texttt{0} bedeutet: Zelle nicht markiert
	\item \texttt{1} bedeutet: Zelle markiert, aber ohne festgelegte Zahl
	\item \texttt{2--10} bedeutet: Zelle markiert mit der Zahl $(i-1)$ festgelegt
\end{itemize}

Das Anfrageformat ist wie folgt strukturiert:

\begin{verbatim}
	struct Input {
		data: Vec<usize>,
		length: usize,
		markingmode: bool,  
	}
\end{verbatim}

Dabei gilt:
\begin{itemize}
	\item \texttt{data} enthält die Sudoku-Daten gemäß der obigen Repräsentation und bildet ein Tupel der entsprechenden Größe (16, 36 oder 81).
	\item \texttt{length} wiederholt der Übersicht halber die Länge der Daten.
	\item \texttt{markingmode} legt die Repräsentationsart fest (\texttt{true} zum Generieren, \texttt{false} zum Lösen).
\end{itemize}

Das Backend verarbeitet die Anfrage und liefert eine Antwort im folgenden Format zurück:

\begin{verbatim}
	struct Output {
		data: Vec<i32>,
		solution: Vec<i32>,
		hassolution: bool,
	}
\end{verbatim}

Die Repräsentation ist nun vereinfacht:
\begin{itemize}
	\item \texttt{0} steht für eine leere Zelle
	\item \texttt{1-9} steht für eine belegte Zelle mit der jeweiligen Zahl
\end{itemize}

\texttt{data} enthält das vom Backend gelieferte (ggf. unvollständige) Sudoku.  
\texttt{solution} stellt die vollständig ausgefüllte Lösung zum Vergleich bereit.  
\texttt{hassolution} gibt an, ob für das Sudoku überhaupt eine gültige Lösung existiert.


\subsubsection{Frontend Code}
Das Frontend erstellt aus den Nutzereingaben ein JSON-Objekt und sendet dieses per \texttt{POST}-Anfrage an das Backend. JavaScript Beispiel:

\begin{verbatim}
	fetch('/api/endpoint', {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ key: 'value' })
	})
	.then(response => response.json())
	.then(data => {
		// Daten verarbeiten und UI aktualisieren
	});
\end{verbatim}